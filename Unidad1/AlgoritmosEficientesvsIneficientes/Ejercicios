import time
import random

def busqueda_lineal(lista, objetivo):
    """
    Implementa búsqueda lineal O(n)
    Retorna posición del elemento o -1 si no existe
    """
    for i in range(len(lista)):
        if lista[i] == objetivo:
            return i
    return -1

def busqueda_binaria(lista, objetivo):
    """
    Implementa búsqueda binaria O(log n)
    PRECONDICIÓN: lista debe estar ordenada
    """
    izquierda, derecha = 0, len(lista) - 1
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        if lista[medio] == objetivo:
            return medio
        elif lista[medio] < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
    return -1

def medir_tiempo(algoritmo, lista, elementos):
    """
    Mide el tiempo promedio de ejecución para un algoritmo de búsqueda.
    """
    total_tiempo = 0
    for elemento in elementos:
        inicio = time.perf_counter()
        algoritmo(lista, elemento)
        fin = time.perf_counter()
        total_tiempo += (fin - inicio)
    return total_tiempo / len(elementos)

# Generar datos y realizar mediciones
tamanos = [1000, 10000, 50000, 100000]
resultados = {}

for tamano in tamanos:
    lista_ordenada = sorted([random.randint(0, tamano * 2) for _ in range(tamano)])
    
    # Seleccionar 5 elementos existentes y 5 no existentes
    elementos_existentes = [lista_ordenada[random.randint(0, tamano - 1)] for _ in range(5)]
    elementos_no_existentes = [tamano * 3 + i for i in range(5)]
    elementos_a_buscar = elementos_existentes + elementos_no_existentes
    
    tiempo_lineal = medir_tiempo(busqueda_lineal, lista_ordenada, elementos_a_buscar)
    tiempo_binario = medir_tiempo(busqueda_binaria, lista_ordenada, elementos_a_buscar)
    
    resultados[tamano] = {
        "lineal": tiempo_lineal,
        "binaria": tiempo_binario,
        "ratio": tiempo_lineal / tiempo_binario
    }

print("Tabla de Resultados:")
print("-" * 50)
print(f"{'Tamaño':<10}{'Búsqueda Lineal (s)':<20}{'Búsqueda Binaria (s)':<20}{'Ratio (Lineal/Binaria)':<25}")
print("-" * 50)
for tamano, tiempos in resultados.items():
    print(f"{tamano:<10}{tiempos['lineal'] * 1e6:<20.2f}{tiempos['binaria'] * 1e6:<20.2f}{tiempos['ratio'] :<25.2f}")
print("-" * 50)


import time
import random

def bubble_sort(lista):
    """Implementa el algoritmo de ordenamiento Bubble Sort."""
    n = len(lista)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if lista[j] > lista[j+1]:
                lista[j], lista[j+1] = lista[j+1], lista[j]
                swapped = True
        if not swapped:
            break
    return lista

def merge_sort(lista):
    """Implementa el algoritmo de ordenamiento Merge Sort."""
    if len(lista) > 1:
        mitad = len(lista) // 2
        izquierda = lista[:mitad]
        derecha = lista[mitad:]

        merge_sort(izquierda)
        merge_sort(derecha)

        i = j = k = 0

        while i < len(izquierda) and j < len(derecha):
            if izquierda[i] < derecha[j]:
                lista[k] = izquierda[i]
                i += 1
            else:
                lista[k] = derecha[j]
                j += 1
            k += 1

        while i < len(izquierda):
            lista[k] = izquierda[i]
            i += 1
            k += 1

        while j < len(derecha):
            lista[k] = derecha[j]
            j += 1
            k += 1
    return lista

def medir_tiempo(algoritmo, datos):
    """Mide el tiempo de ejecución de un algoritmo de ordenamiento."""
    copia_datos = datos[:]
    inicio = time.perf_counter()
    algoritmo(copia_datos)
    fin = time.perf_counter()
    return fin - inicio

# Generar datos y realizar mediciones
dimensiones_ordenamiento = [100, 500, 1000, 5000, 10000]
resultados_rendimiento = {}

for dim in dimensiones_ordenamiento:
    datos_aleatorios = random.sample(range(dim * 2), dim)
    tiempo_bs = medir_tiempo(bubble_sort, datos_aleatorios)
    tiempo_ms = medir_tiempo(merge_sort, datos_aleatorios)
    
    resultados_rendimiento[dim] = {
        "bubble_sort": tiempo_bs,
        "merge_sort": tiempo_ms,
        "relacion": tiempo_bs / tiempo_ms if tiempo_ms > 0 else float('inf')
    }

print("Tabla 2.1 - Tiempos de Ejecución por Dimensión:")
print("-" * 60)
print(f"{'Dimensión':<10}{'Bubble Sort (s)':<20}{'Merge Sort (s)':<20}{'Relación BS/MS':<20}")
print("-" * 60)
for dim, tiempos in resultados_rendimiento.items():
    print(f"{dim:<10}{tiempos['bubble_sort']:.6f}{tiempos['merge_sort']:.6f}{tiempos['relacion']:.2f}")
print("-" * 60)


# Casos de prueba específicos
n = 1000
secuencia_ordenada = list(range(n))
secuencia_inversa = list(range(n, 0, -1))
secuencia_casi_ordenada = sorted(list(range(n)))
secuencia_casi_ordenada[n//4], secuencia_casi_ordenada[n//2] = secuencia_casi_ordenada[n//2], secuencia_casi_ordenada[n//4]
secuencia_casi_ordenada[n-1], secuencia_casi_ordenada[n-100] = secuencia_casi_ordenada[n-100], secuencia_casi_ordenada[n-1]
# Opcional, para casos más extremos se puede usar:
# secuencia_casi_ordenada = [x if x % 100 != 0 else x+500 for x in range(1000)]

# Medir y almacenar resultados
resultados_casos = {}
casos = {
    "Ordenado": secuencia_ordenada,
    "Inverso": secuencia_inversa,
    "Casi ordenado": secuencia_casi_ordenada
}

for caso, datos in casos.items():
    tiempo_bs = medir_tiempo(bubble_sort, datos)
    tiempo_ms = medir_tiempo(merge_sort, datos)
    resultados_casos[caso] = {
        "bubble_sort": tiempo_bs,
        "merge_sort": tiempo_ms
    }

print("\nTabla 2.2 - Comportamiento en Casos Específicos (n=1000):")
print("-" * 80)
print(f"{'Escenario':<20}{'Bubble Sort (s)':<20}{'Merge Sort (s)':<20}{'Observaciones':<20}")
print("-" * 80)
for caso, tiempos in resultados_casos.items():
    obs = ""
    if caso == "Ordenado":
        obs = "Mejor caso para Bubble Sort"
    elif caso == "Inverso":
        obs = "Peor caso para Bubble Sort"
    elif caso == "Casi ordenado":
        obs = "Bubble Sort se beneficia de esto"

    print(f"{caso:<20}{tiempos['bubble_sort']:.6f}{tiempos['merge_sort']:.6f}{obs:<20}")
print("-" * 80)


import time
import sys

# Para evitar el error de recursión infinita en casos grandes
sys.setrecursionlimit(2000)

def fib_recursivo(n):
    """
    Implementación recursiva O(2ⁿ)
    CUIDADO: Muy lenta para n > 35
    """
    if n <= 1:
        return n
    else:
        return fib_recursivo(n-1) + fib_recursivo(n-2)

def fib_iterativo(n):
    """Implementación iterativa O(n)"""
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def fib_memoization(n, memo={}):
    """BONUS: Implementación con memoization O(n)"""
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memoization(n - 1, memo) + fib_memoization(n - 2, memo)
    return memo[n]

# 3.1: Medición de Tiempos de Cálculo
valores_n = [5, 10, 20, 30, 35]
resultados = {}

for n in valores_n:
    # Medir tiempo para la versión recursiva
    start_time_rec = time.time()
    res_rec = fib_recursivo(n)
    end_time_rec = time.time()
    
    # Medir tiempo para la versión iterativa
    start_time_it = time.time()
    res_it = fib_iterativo(n)
    end_time_it = time.time()

    # Verificar que los resultados sean correctos
    assert res_rec == res_it, f"Resultados incorrectos para n={n}"
    
    resultados[n] = {
        "recursivo": end_time_rec - start_time_rec,
        "iterativo": end_time_it - start_time_it
    }

print("Tabla de Resultados de Tiempos de Cálculo:")
print("-" * 50)
print(f"{'n':<10}{'Fibonacci':<15}{'Recursivo (s)':<20}{'Iterativo (s)':<20}{'Diferencia (s)':<20}")
print("-" * 50)
for n, times in resultados.items():
    fib_val = fib_iterativo(n)
    diferencia = times['recursivo'] - times['iterativo']
    print(f"{n:<10}{fib_val:<15}{times['recursivo']:.8f}{times['iterativo']:.8f}{diferencia:.8f}")
print("-" * 50)


# 3.2: Límites Prácticos
# Límites para la versión recursiva
n_recursivo = 1
start_time = time.time()
while (time.time() - start_time) < 30 and n_recursivo <= 40:
    fib_recursivo(n_recursivo)
    n_recursivo += 1
max_n_recursivo = n_recursivo - 2 if n_recursivo > 1 else 0

# Límites para la versión iterativa
n_iterativo = 1
start_time = time.time()
while (time.time() - start_time) < 30 and n_iterativo <= 100000:
    fib_iterativo(n_iterativo)
    n_iterativo += 1
max_n_iterativo = n_iterativo - 2 if n_iterativo > 1 else 0

print("\nAnálisis de Límites Prácticos:")
print("-" * 40)
print(f"{'Versión':<20}{'Máximo n en < 30s':<20}")
print("-" * 40)
print(f"{'Recursiva':<20}{max_n_recursivo:<20}")
print(f"{'Iterativa':<20}{max_n_iterativo:<20}")
print("-" * 40)